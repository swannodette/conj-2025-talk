#+title: A ClojureScript Survival Kit
#+date: Clojure/conj 2025
#+author: David Nolen
#+email: david.nolen@gmail.com
#+STARTUP: indent inlineimages

* [[elisp:(my/org-present-inferior-clojure "clojure -M -m cljs.main -d .cljs_repl -re node -r")][Appetizers]] ðŸ§€
#+begin_src clojure
  (println "Hello Clojure/conj 2025!!")
  (map #(* % %) (filter even? (take 10 (range))))
  (assoc {:foo 1} :foo 2)
  (doc assoc)
  (doc js/Array.indexOf)
  (refer-global :only '[Date console HTMLElement])
  (Date.)
  (.log console "Hello again!")
  (doc console.log)
  (doc HTMLElement)
#+end_src  
* What is ClojureScript? ðŸ¤”
** A dialect of Clojure that targets JavaScript runtimes
*** Yummy `clojure.core` ðŸ§
*** Differences: host, compilation model
**** ClojureScript can compile itself into JavaScript
** bundled with Google Closure Library (GCL for short)
*** More on that later ...
** REPL integration with JavaScript runtimes
*** "Hot reloading" ðŸ˜´
** Google Closure Compiler Advanced Optimizations
*** A trivial `cljs.core` program (+ GCL) would be ~3mb of JavaScript
**** But after advanced compilation, only a few bytes
*** More on that later as well ...
* "Clojure rocks ... JS reaches"
** A significant slice of ClojureScript dev is React
*** Clojurists were early adopters
**** Now Functional UI programming status quo
**** React went from a script tag to an all-encompassing ecosystem
*** CLJS+React now mature solution for SPAs / Mobile apps 
** JavaScript tooling came along for the ride
*** Bless shadow-cljs ðŸŒŸ, but complexity lurks ðŸ§›
*** Low JS ecosystem interest in fixing the fundamental problems
**** Just shove the complexity out of sight ðŸ§¹
***** Until of course ... ðŸ¤¯
* Post-apocalyptic Software Dev: A Fairy Tale
ðŸ–¥ðŸ’€ðŸ§š
** Software Zombie Apocalypse
** Imagine ...
*** NPM is gone! No ClojureScript libraries!
*** You have a few git clones on your ðŸ’»
*** Inventory:
**** A) Wits ðŸº
**** B) Bare hands ðŸ™Œ,
**** C) simple, composable tools ðŸ›  
* Take stock of the surroundings ðŸ‘€
** Things have come a long, long way
*** Evergreen Browsers (except Safari)
** CSS is pretty good
*** Nested rules, flexbox
**** CSS tooling feels less necessary
*** More optimization knobs
**** CSS Grid
**** CSS Container
**** CSS content-visible
** Always check what Browser tech offers first
*** [[https://web-platform-dx.github.io/web-features/][Baseline]]
*** [[ https://caniuse.com][Can I use ...]]
* A Survival Kit: Looking inside ðŸ§°
** cljs.core
*** cljs.set
*** cljs.data
*** cljs.test ...
** But we often forget Google Closure Library
*** Way more than goog.object, goog.array ...
*** Not designed to replace Web APIs
**** Ergonomics
**** Many common problems Browsers don't solve
* [[elisp:(my/org-present-inferior-clojure "clojure -M -m cljs.main -d .cljs_browser_repl -r")][Access / Modify the DOM]] ðŸ“– âœ
#+begin_src clojure
  (require '[goog.dom :as gdom])
  (def button (gdom/getElement "click-me"))
  (. button -id)

  (require '[goog.style :as gstyle])
  (gstyle/setStyle button "font-size" "25px")
  (gstyle/setStyle button "border-radius" "8px")
  ;; add something over browsers
  (gstyle/setStyle button
    #js {:margin-left "5px"
         :margin-top  "10px"
         :text-stroke "1px white"})
#+end_src
* [[elisp:(my/org-present-inferior-clojure "clojure -M -m cljs.main -d .cljs_browser_repl -r")][Internationalization]] ðŸŒŽ
#+begin_src clojure
  (set! goog.LOCALE "fr")
  (require '[goog.date :as date])
  (import '[goog.i18n DateTimeFormat])

  (def now (date/DateTime.))
  (def fmt (DateTimeFormat. "EEEE MMMM d, y"))
  (.log js/console (.format fmt now))
#+end_src
* [[elisp:(my/org-present-inferior-clojure "clojure -M -m cljs.main -d .cljs_browser_repl -r")][Positioning]] ðŸ¹
#+begin_src clojure
  (require '[goog.dom :as gdom]
           '[goog.positioning :as gpos]
           '[goog.style :as gstyle])
  (import '[goog.positioning Corner])

  (def button (gdom/getElement "click-me"))
  (def popover (gdom/getElement "popover"))

  (gpos/positionAtAnchor
    button (. Corner -TOP_LEFT)
    popover (. Corner -BOTTOM_LEFT))
  
  (gstyle/setStyle popover #js {:visibility "visible"})
#+end_src
* And much, much more ðŸ¬
** `goog.date.Interval`
** `goog.a11y.aria`
** `goog.dom.getDocumentHeight`, etc.
** `goog.dom.selection`
** `goog.dom.animation` (split read/write)
** `goog.dom.safe` (XSS sanitization)
** `goog.math.Integer` (arbitrary precision)
** `goog.ui.*` (autocomplete, tooltips, treecontrol, datepicker ...)
** `goog.math.vec`
** `goog.userAgent`
** `goog.history`
** `goog.uri`
** `goog.crypt.*`
** ...
* GCL is not familiar ðŸ‘¾
** ... But LLMs know a bit about Google Closure Library
*** I asked Claude a bunch of questions for this talk!
** The GCL source is very approachable
*** Really boring code in the best possible way
*** Lots of comments
** HELP WANTED! ðŸ‘· GCL docs at the https://clojurescript.org
*** Update styling, static pages for everything
*** Would be great to have examples for all of the UI components with CLJS translations
* Wait, what about UI = Î»(State)? ðŸ¤”
** HTML -> HTML
*** HTMX / Rails Turbo / Pheonix Live View / Datastar
*** Morphdom, Idiomorph, Morphlex ...
**** Can be used as script tags
** Pure CLJS solutions
*** Replicant ðŸŽ‰
*** shadow-grove
* [[elisp:(my/org-present-inferior-clojure "clojure -M -m cljs.main -d .cljs_browser_repl -r")][Morphing Demo]] 
#+begin_src clojure
  ;; 13 year old lib from Chris Granger of LightTable
  (require '[crate.core :as crate]
           '[goog.dom :as gdom])
  ;; new, just use globlal libs as libs
  ;; this library is 2 weeks old
  (require-global '[morphlex :as morphlex])

  (def button (gdom/getElement "click-me"))

  (defn render-button [new-text]
    (crate/html
      [:button#click-me {} new-text]))

  (morphlex/morph button
    (render-button "CLJS Really Rocks! ðŸª¨  ðŸª¨  ðŸª¨"))
#+end_src
* Escaping Framework Feudalism âš”
** Frameworks keep recreating the same components
*** Over, and over and over again
** Frameworks don't really interoperate
*** Components are "reusable" only within these walls
** Too bad we can't create custom HTML tags ...
*** Except we can!
**** Web Components ðŸ§©
* [[elisp:(my/org-present-inferior-clojure "clojure -M -m cljs.main -d .cljs_browser_repl -r")][Web Components with ClojureScript]] 
#+begin_src clojure
  (require-macros '[conj-2025.core :refer [defel]])
  (require '[goog.dom :as gdom])
  (refer-global :only '[console customElements])

  (defel MyEl []
    (connectedCallback [this]
      (.log console "Connected!"))
    (disconnectedCallback [this]
      (.log console "Goodbye!")))

  (.define customElements "my-el" MyEl)

  (def main (gdom/getElement "main"))
  (def my-el (gdom/createElement "my-el"))
  (gdom/setTextContent my-el "My WebComponent Element")
  (gdom/appendChild main my-el)
  (gdom/removeNode my-el)
#+end_src
* Putting it all together (DEMO)
** Recipe
*** Move everything to the backend
*** Full page morph on the client (!)
*** Complex interactivity
**** Mixture of Web Components / Direct DOM Manipulation
** Result
*** <30K brotli JS vs. 6mb
**** Mostly WebComponent glue
***** Don't need persistent data structures at all
*** 20X-37X less memory
*** LCP 0.2s vs. 1.5s - Google thinks 2.5s is good ðŸ˜­
*** Scripting/Paint 1.5:1 vs. 40:1
* Oh ... One More Thing
** ClojureScript starts at ~20K compresssed
** Can it get smaller?
*** How much smaller?
** *A matter of principle ...
*** I like to use ClojureScript anywhere
**** I loved using it on my blog
*** Sometimes I want to do something lower level
**** Just want macros etc.
* Enter =:lite-mode=
** Uses the copy-on-write data structures from 2011 
*** Much, much simpler implementations
*** Simpler relationships
** `:elide-to-string`
*** printing has to know about all the types
*** `.toString` impls pull in `pr` machinery
** Rough numbers, `:lite-mode` + `:elide-to-string`
*** `(.log console :foo) is` 5K, bytes after compression
*** `(seq {...})` 6K brotli
*** The following is 6K brotli
#+begin_src clojure
  (->> (map inc (range 10))
    (filter even?)
    (partition 2)
    (drop 1)
    (mapcat identity)
    into-array))
#+end_src
* Is =:lite-mode= for me?
** For existing large applications?
*** Nope!
** Need some light interactivity on a static website?
*** Absolutely!
** Considering a different architecture for your web application?
*** Assess!
* What =:lite-mode= is not
** If your work is fundamentally >20K compressed, not useful
*** Few benefits, ClojureScript already =very good=
**** Good enough for 1MB, 512K, 256K, 128K clubs
*** Example: Trivial Replicant is 1/3 to 1/2 size of trivial CLJS+React
** <5K, start cutting corners ðŸ©¹
*** `:lite-mode` is just CLJS, everything works
**** We run most of standard suite against it
*** checkout squint-cljs
* Takeaways
** Our approach is one of many - a variety of tradeoffs
*** Key point: Embraced a Clojure(Script)-centric view
**** While freely lifting good ideas from elsewhere
*** Really excited about it!
**** See David Yang's talk for more details
** Clojure(Script)-centric solutions
*** Simpler tooling
*** Simpler dependencies
*** Simpler semantics
*** Smaller bundles
** Just Use ClojureScript!
* ClojureScript Adapts
** Use it for jQuery-style development (2006)
** Use it for React-style development (2013)
** Use it for HTMX-style development (2020)
** Use it for D*-style development (2025)
** Invent something new & alien! (????) ðŸ‘½
* Thank You! ðŸ«¶ 
ðŸ–¥ðŸ’€ðŸ§š
* Resources
** [[https://google.github.io/closure-library/api/][Google Closure Library API]]
** [[https://github.com/clojure/closure-library][Google Closure Library Source]]
** [[https://htmx.org][HTMX]], [[https://dev.37signals.com/a-happier-happy-path-in-turbo-with-morphing/][Rails Turbo]], [[https://pragmaticstudio.com/tutorials/the-life-cycle-of-a-phoenix-liveview][Pheonix Live View]]
** [[https://data-star.dev][Datastar*]]
** [[https://github.com/bigskysoftware/idiomorph][Idiomorph]]
# Local Variables:
# fill-column: 80
# word-wrap: t
# org-hide-leading-stars: t
# org-modern-star: replace
# org-modern-replace-stars: ("Â§" "â¯" "â—‹" "â– " "â˜…")
# image-animate-loop: t
# eval: (when org-modern-mode (org-modern-mode -1) (org-modern-mode 1))
# eval: (my/animate-images)
# eval: (local-set-key (kbd "C-x C-e") 'my/org-present-eval-last-sexp)
# End:
