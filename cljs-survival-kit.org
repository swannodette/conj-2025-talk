#+title: A ClojureScript Survival Kit
#+date: Clojure/conj 2025
#+author: David Nolen
#+email: david.nolen@gmail.com
#+STARTUP: indent inlineimages

* [[elisp:(my/org-present-inferior-clojure "clojure -M -m cljs.main -d .cljs_repl -re node -r")][Demo]]
#+begin_src clojure
  (println "Hello Clojure/conj 2025!!")
  (map #(* % %) (filter even? (take 10 (range))))
  (assoc {:foo 1} :foo 2)
  (doc js/Array.indexOf)
  (doc js/HTMLElement)
#+end_src
* What is ClojureScript? ğŸ¤”
** A dialect of Clojure that targets JavaScript runtimes
*** Yummy `clojure.core` ğŸ§
*** Differences: host, compilation model
**** ClojureScript can compile itself into JavaScript
** Google Closure Library (GCL for short)
*** More on that later ...
** REPL integration with JavaScript runtimes
*** "Hot reloading" ğŸ˜´
*** Stop drawing dead fish ğŸŸ
** Google Closure Compiler Advanced Optimizations
*** A trivial `cljs.core` program (+ GCL) is ~3mb of JavaScript
**** After advanced compilation, ~3 bytes
*** More on that later as well ...
* JavaScript Practice Today ğŸ“…
:PROPERTIES:
:org-image-actual-width: 700
:END:
[[file:fine.jpg]]
* JavaScript Practice Tomorrow ğŸ“†
:PROPERTIES:
:org-image-actual-width: 700
:END:
[[file:homer.gif]]
* "Clojure rocks ... JS reaches"
** A significant slice of ClojureScript dev is React
*** Clojurists were early adopters
**** Now Functional UI programming status quo
**** React went from a script tag to an all-encompassing ecosystem
*** CLJS+React now mature solution for SPAs / Mobile apps 
** ... but JavaScript tooling is very "easy" ... not simple
*** God bless shadow-cljs ğŸŒŸ, but complexity lurks ğŸ§›
*** No JS ecosystem interest in fixing the fundamental problem
**** Just shove the complexity out of sight ğŸ§¹
***** Until of course ... ğŸ¤¯
* Post-apocalyptic Software Dev: A Fairy Tale
ğŸ–¥ğŸ’€ğŸ§š
** Software Zombie Apocalypse
** Imagine ...
*** NPM is gone! No ClojureScript libraries!
*** You have a few git clones on your ğŸ’»
*** Inventory:
**** A) Wits ğŸº
**** B) Bare hands ğŸ™Œ,
**** C) simple, composable tools ğŸ›  
* A Survival Kit: Looking inside ğŸ§°
** What's in the box
*** cljs.core, cljs.string, cljs.pprint, ...
*** goog, goog.string, goog.array, ...
** Things we might have forgotten were in the box ğŸ‘µ
*** DOM APIs
*** CSS patterns / optimizations
** Techniques outside the box ğŸ§ 
*** AJAX / HTMX
*** Morphing
* [[elisp:(my/org-present-inferior-clojure "clojure -M -m cljs.main -d .cljs_browser_repl -r")][Access / Modify the DOM]] ğŸ“– âœ
#+begin_src clojure
  (require '[goog.dom :as gdom])
  (def button (gdom/getElement "click-me"))
  (. button -id)

  (require '[goog.style :as gstyle])
  (gstyle/setStyle button "font-size" "100px")
  (gstyle/setStyle button "border-radius" "25px")
  (gstyle/setStyle button
    #js {:margin-left "50px"
         :margin-top  "25px"
         :text-stroke "1px white"})
#+end_src
* Event handling ğŸ’¬
#+begin_src clojure
  (require '[goog.dom :as gdom])
  (require '[goog.events :as gevents])
  (def button (gdom/getElement "click-me"))
  (defn update-button [s]
    ;;(gdom/setText s)
    (gdom/setTextContent button s))
  (gevents/listen button
    #js ["click", "mouseenter" "mouseleave"]
    (fn [e]
      (case (. e -type)
        "mouseenter" (update-button "HI!")
        "mouseleave" (update-button "BYE!")
        "click"      (update-button "OUCH!"))))
#+end_src
* Time manipulation ğŸ•°
#+begin_src clojure
  (require '[goog.date])
  (def now (goog.date/DateTime.))
  ;; 3 days and 1 hour
  (def interval (goog.date.Interval. 0 0 3 1))
  (def later (.clone now))
  (.add later interval)
  (.log js/console later)
#+end_src
* Internationalization ğŸŒ
#+begin_src clojure
  (set! goog.LOCALE "fr")
  (require '[goog.date :as date])
  (import '[goog.i18n DateTimeFormat])

  (def now (date/DateTime.))
  (def fmt (DateTimeFormat. "EEEE MMMM d, y"))
  (.log js/console (.format fmt now))
#+end_src
* Accessibility âˆ€
#+begin_src clojure
  (require '[goog.a11y.aria :as aria]
           '[goog.dom :as gdom]
           '[goog.events :as gevents])
  (import '[goog.a11y.aria State PressedValues])

  (def button (gdom/getElement "click-me"))

  (def initial-str "This button does something really cool!")
  (aria/setLabel button initial-str)
  (aria/setState button State/PRESSED (. aria/PressedValues -FALSE))

  (gevents/listen button "click"
    (fn [_]
      (let [pressed? (= (. PressedValues -TRUE)
                        (aria/getState button State/PRESSED))]
        (if pressed?
          (aria/setState button State/PRESSED (. PressedValues -FALSE))
          (aria/setState button State/PRESSED (. PressedValues -TRUE)))
        (aria/setLabel button 
          (if pressed? "Isn't this really cool?" initial-str)))))
#+end_src
* Positioning ğŸ§©
#+begin_src clojure
  (require '[goog.dom :as gdom]
           '[goog.positioning :as gpos]
           '[goog.style :as gstyle])
  (import '[goog.positioning Corner AnchoredPosition])

  (def button (gdom/getElement "click-me"))
  (def popover (gdom/getElement "popover"))

  (gpos/positionAtAnchor
    button (. Corner -BOTTOM_LEFT)
    popover (. Corner -TOP_LEFT))
  
  (gstyle/setStyle popover #js {:visibility "visible"})
#+end_src
* And much, much more
** `goog.a11y.aria` (handles validation)
** `goog.dom.getDocumentHeight` etc.
** `goog.dom.selection` (unified DOM selection API)
** `goog.dom.animation` (split read/write)
** `goog.dom.ViewportSizeMonitor`
** `goog.dom.safe` (XSS sanitization)
** goog.math.integer (arbitrary precision)
** goog.ui.* (many, many widgets)
** goog.math.vec, goog.useragent, goog.histry, goog.uri, goog.crypt.* ...
* GCL is not familiar ğŸ‘¾
** LLMs know a lot about Google Closure Library
*** I asked Claude a bunch of questions for this talk!
** The source is very approachable
*** Really boring code in the best possible way
*** Lots of comments
** HELP WANTEED! ğŸ‘· GCL docs at the https://clojurescript.org
*** Update styling, remove the javascript to navigate
*** Would be great to have examples for all of the UI components w/ CLJS translations
* Advanced Compilation ğŸ—œ
** Compiling `cljs.core` generates 1.3mb of JS
** Pay for what you use
*** If you just print a string, throw the rest away
*** `(.log console "Hello!")` should emit only that!
** Two aspects of `cljs.core` make dead code elimination challenging
*** All the data structures refer to each other
*** Printing is recursive and dynamic, so the details of `pr-str` pulls in everyone.
*** Enter `:lite-mode` ... more on that later!
** If you're designing a library you should have strong intuition about problematic patterns
*** Top level side effects (non-namespace stuff)
**** Multimethods / Atoms
* Lite Mode & Friends ğŸ”¬
** Use the original copy-on-write data structures
*** Much, much simpler implementations
**** Simpler relationships
** `:elide-to-string`
*** printing has to know about all the types
** Rough numbers `:lite-mode` + `:elide-to-string`
*** `(.log js/console :foo) is` 5K, bytes after compression
*** `(seq {...})` 6K brotli
*** The following is 6K brotli:
#+begin_src clojure
  (->> (map inc (range 10))
    (filter even?)
    (partition 2)
    (drop 1)
    (mapcat identity)
    into-array))
#+end_src
* The final artifact (20k/6k brotli) ğŸ”
:PROPERTIES:
:org-image-actual-width: 700
:END:
[[file:smap.jpg]]


* "Plain" JavaScript (~4K gzipped) 
#+begin_src javascript 
  import {produce} from "immer"
  const baseState = [
      {title: "Learn TypeScript", done: true},
      {title: "Try Immer" done: false}
  ]
  const nextState = produce(baseState, draft => {
      draft[1].done = true
      draft.push({title: "Tweet about it"})
  });
#+end_src
** CLJS now in ballpark of "hand-written" JS in many cases
*** Without manual intervention / customized tooling
* Building a new foundation ğŸ™
** DCE-sensitive ClojureScript libraries
*** Library authors should be DCE experts
**** Also test `:lite-mode` true
** Google Closure Library fresh
*** Get GCL under our finger tips
*** Follow and synchronize w/ evolving standards
** Light DOM morphing
*** Morphdom
*** Idiomorph
*** Morphlex
** Scoped Reactive Signals?
** See Datastar
* Light DOM Web Components ğŸŒ…
** Web Components for a long time synonymous w/ Shadow DOM
*** Shadow DOM is complected
*** If you decomplect
**** plain Web Components
** Web Components work more or less like native components
*** Thus they work with every framework
*** They work with any diffing approach
* Dynamically Constructing Web Components
#+begin_src javascript
  function Popover() {
      return Reflect.construct(HTMLElement,[],PopOver);
  }

  PopOver.prototype = Object.create(
      HTMLElement.prototype, {
          connectedCallback: {
              configurable: true,
              "value": function() {
                  console.log("WHOA!");
              }
          }
      }
  );
#+end_src
* Putting it all together (DEMO)
** 13K gzipped CLJS vs. 6mb
*** Mostly WebComponent glue
**** Don't need persistent data structures at all
** 20X-37X less memory
** LCP 0.2s vs. 1.5s - Google thinks 2.5s is good ğŸ˜­
** Scripting/Paint 1.5:1 vs. 40:1
* ClojureScript adapts!
** Use it for jQuery-style development
** Use it for React-sytle development
** Use it for HTMX-style development
** Use it for D*-style development
** Invent something new that bucks the status quo!
* Thank You! ğŸ«¶
ğŸ–¥ğŸ’€ğŸ§š
# Local Variables:
# fill-column: 80
# word-wrap: t
# org-hide-leading-stars: t
# org-modern-star: replace
# org-modern-replace-stars: ("Â§" "â¯" "â—‹" "â– " "â˜…")
# image-animate-loop: t
# eval: (when org-modern-mode (org-modern-mode -1) (org-modern-mode 1))
# eval: (my/animate-images)
# eval: (local-set-key (kbd "C-x C-e") 'my/org-present-eval-last-sexp)
# End:
