#+title: A ClojureScript Survival Kit
#+date: Clojure/conj 2025
#+author: David Nolen
#+email: david.nolen@gmail.com
#+STARTUP: indent inlineimages

* [[elisp:(my/org-present-inferior-clojure "clojure -M -m cljs.main -d .cljs_repl -re node -r")][Demo]]
#+begin_src clojure
  (println "Hello Clojure/conj 2025!!") 
  (map #(* % %) (filter even? (take 10 (range))))
  (assoc {:foo 1} :foo 2)
  (doc js/Array.indexOf)
  (doc js/HTMLElement)
#+end_src
* What is ClojureScript?
** A dialect of Clojure that targets JavaScript runtimes
*** Delivers a significant slice of `clojure.core`
** Includes a very large JavaScript standard library via Google Closure Library (GCL)
*** More on that later ...
** REPL integration with JavaScript runtimes (Browser, Node.js, V8/JSC Mobile)
*** Stop drawing dead fish üêü
** Tightly integrated with Google Closure Compiler Advanced Optimizations
*** A trivial `cljs.core` program (+ GCL) is ~3mb of JavaScript
**** After advanced compilation, ~3 bytes
*** More on that later as well ...
* JavaScript Practice Today
:PROPERTIES:
:org-image-actual-width: 800
:END:
[[file:fine.jpg]]
* JavaScript Practice Tomorrow
:PROPERTIES:
:org-image-actual-width: 800
:END:
[[file:homer.gif]]
* "Because Clojure rocks, and JavaScript reaches" - Some Person
** A lot of ClojureScript dev is React
*** Clojurists were early adopters
**** Now functional UI programming is the norm
*** React went from a script tag to an all-encompassing ecosystem
*** The community has a good grasp on succeeding with it
**** Web apps & React Native
** ... but JavaScript tooling is very "easy" ... not simple
*** God bless shadow-cljs üåü, but the complexity continues to pile up
** ClojureScript provides a smaller set of tools to get the job done
*** Once intimidating, now seems positively tame
*** fighweel / shadow-cljs also simple if you drop JS ecosystem integration
** But how do you do it?
* Post-apocalyptic Software Development: A Fairy Tale
üñ•üíÄüßö
** Software Zombie Apocalypse
*** Nobody remembers how to do anything anymore!
** Imagine ...
*** NPM is gone!
*** No ClojureScript libraries!
*** You have a few git clones on your üíª
*** Inventory: A) Wits üßó, B) Bare hands üôå, C) simple, composable tools üõ†
* A Survival Kit: Looking inside
** What's in the box
*** cljs.core, cljs.string, cljs.pprint, ...
*** goog, goog.string, goog.array, ...
** Thing we forgot were in the box
*** new DOM APIs
*** CSS patterns / optimizations
** Techniques outside the box üß†
*** AJAX / HTMX
*** Morphing - you could write it! (nanomorph.js)
* Light scripting
** Let's add some interactivity
** Let's use a REPL
** Let's build it
* Let's explore the output
* Google Closure Library
** Google stopped maintaining it (externally)
*** So we forked it
** Still a rock solid option for a great many tasks
** Written with a 
* Time manipulation
* Internationalization
* Accessibility
* Advanced Compilation
** Pay for what you use
#+begin_src clojure
(.log js/console "Hello world!")
#+end_src
** Closure understand unused literals
** Two aspects of `cljs.core` make dead code elimination challenging
*** All the data structures refer to each other
*** Printing is recursive and dynamic, so the details of `pr-str` pulls in everyone.
*** Enter `:lite-mode` ... more on that later!
* Lite Mode
** Use the original copy-on-write data structures
*** Much simpler implementations
** `:elide-to-string`
*** printing has to know about all the types
** The following is 6K brotli
#+begin_src clojure
  (->> (map inc (range 10))
    (filter even?)
    (partition 2)
    (drop 1)
    (mapcat identity)
    into-array))
#+end_src
* Light DOM Web Components
** Web Components for a long time synonymous w/ Shadow DOM
*** Shadow DOM is complected
*** If you decomplect
**** plain Web Components
** Web Components work more or less like native components
*** Thus they work with every framework
*** They work with any diffing approach
* Dynamically Constructing Web Components
#+begin_src javascript
  function Popover() {
      return Reflect.construct(HTMLElement,[],PopOver);
  }

  PopOver.prototype = Object.create(
      HTMLElement.prototype, {
          connectedCallback: {
              configurable: true,
              "value": function() {
                  console.log("WHOA!");
              }
          }
      }
  );
#+end_src
* Where is all this stuff coming from?
** Source Map Explorer
* Introspect DOM APIs at REPL
* How can I manipulate the DOM?
** Setting attributes
** Setting styles
* How can I listen for events
** Can I listen for multiple events
** Can I delegate events
* How can I make a custom component
** Can update that component in a functional way?
* How can I build an app?
** Client/Server state management
*** Synchronization complexity
** Client state management
*** Synchronization complexity
** Server management
*** Hrm ...
* Expanding the toolbox üèö
* The Book of AJAX
** innerHTML/outerHTML
* The Book of React
** Diffing the DOM
** Idiomorph
* Smoothing things out
** Using Google Closure to disambiguate methods / namespaces / fields
* Why ClojureScript in 2025?
** Functional programming
** REPL Driven Development
** Batteries included
** Maximum functionality / Minimal Artifact
** Radically different approach software development
* ClojureScript & JS Status Quo
** Clojure community lead the jump to React
** But 10+ years on, perhaps time to lead the way again
** ClojureScript + React is practical
* Why not just TypeScript?
** Another brick in the wall 
** We can assert our differing philosophies without abandoning our responsibilities
*** The Lisp Curse?
* Thank You!
* Presentation Variables
# Local Variables:
# fill-column: 80
# word-wrap: t
# org-hide-leading-stars: t
# org-modern-star: replace
# org-modern-replace-stars: ("¬ß" "‚ùØ" "‚óã" "‚ñ†" "‚òÖ")
# image-animate-loop: t
# eval: (when org-modern-mode (org-modern-mode -1) (org-modern-mode 1))
# eval: (my/animate-images)
# End:
